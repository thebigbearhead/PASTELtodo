// PASTEL TODO â€” Hard Layout 60x30 (Tab Header Ã—2, Tab Body Ã—1)
// -------------------------------------------------------------
// Fixed layout: width 60, height 30. ASCII borders only.
// Header uses double tab (\t\t), body uses single tab (\t).
// If terminal smaller than 60x30 â†’ exit with error.
// -------------------------------------------------------------

use chrono::{DateTime, Local};
use crossterm::event::{self, Event, KeyCode, KeyEvent, KeyModifiers};
use crossterm::terminal::{disable_raw_mode, enable_raw_mode};
use std::fs::{self, File};
use std::io::{self, BufRead, BufReader, Write};
use std::path::PathBuf;
use std::time::Duration;

const RESET: &str = "\x1b[0m";
const TITLE: &str = "\x1b[38;5;218m";
const ACCENT: &str = "\x1b[38;5;117m";
const TODO_COLOR: &str = "\x1b[38;5;110m";
const DONE_COLOR: &str = "\x1b[38;5;150m";
const DATE_COLOR: &str = "\x1b[38;5;186m";
const FOLDER_COLOR: &str = "\x1b[38;5;213m";
const TIP_TEXT: &str = "\x1b[38;5;244m";
const ITALIC: &str = "\x1b[3m";
const DIM: &str = "\x1b[2m";

const TABLE_WIDTH: usize = 60;
const TASK_COLUMN_WIDTH: usize = 36;
const MAX_VISIBLE_TASKS: usize = 6;

// ðŸ‘‰ Layout size configuration
// -------------------------------------------------------------
// Minimum terminal size (change these numbers if needed)
const MIN_WIDTH: u16 = 60;
// Minimum height (change if you want taller layout)
const MIN_HEIGHT: u16 = 30;
// -------------------------------------------------------------

#[derive(Debug, Clone, PartialEq)]
struct Task {
    text: String,
    done: bool,
    folder: String,
    created_at: DateTime<Local>,
}

enum Mode {
    Command,
    Navigate { selected: usize },
}

struct RawModeGuard;
impl RawModeGuard {
    fn new() -> io::Result<Self> {
        enable_raw_mode()?;
        Ok(Self)
    }
}
impl Drop for RawModeGuard {
    fn drop(&mut self) {
        let _ = disable_raw_mode();
    }
}

fn main() {
    let (cols, rows) = crossterm::terminal::size().unwrap_or((80, 24));
    if cols < MIN_WIDTH || rows < MIN_HEIGHT {
        eprintln!(
            "\x1b[31mError: Terminal must be at least {}x{} (current: {}x{})\x1b[0m",
            MIN_WIDTH, MIN_HEIGHT, cols, rows
        );
        std::process::exit(1);
    }

    let mut tasks = load_tasks();
    let mut current_folder = tasks
        .first()
        .map(|t| t.folder.clone())
        .unwrap_or_else(|| "inbox".to_string());

    let _raw = RawModeGuard::new().expect("Cannot enable raw mode");

    let mut mode = Mode::Command;
    let mut buffer = String::new();

    loop {
        render(&tasks, &current_folder, &mode, &buffer);

        if event::poll(Duration::from_millis(100)).unwrap() {
            if let Event::Key(key) = event::read().unwrap() {
                if handle_key(key, &mut mode, &mut buffer, &mut tasks, &mut current_folder) {
                    break;
                }
            }
        }
    }
}

// ---- Render fixed layout 60x30 ----
fn render(tasks: &[Task], folder: &str, mode: &Mode, cmd: &str) {
    print!("\x1b[2J\x1b[H"); // clear screen + move to top-left

    let folder_indices: Vec<usize> = tasks
        .iter()
        .enumerate()
        .filter(|(_, t)| t.folder == folder)
        .map(|(idx, _)| idx)
        .collect();
    let folder_count = folder_indices.len();
    let selected_idx = match mode {
        Mode::Navigate { selected } if folder_count > 0 => Some((*selected).min(folder_count - 1)),
        _ => None,
    };
    let mut start = 0usize;
    if let Some(sel) = selected_idx {
        if sel + 1 > MAX_VISIBLE_TASKS {
            start = sel + 1 - MAX_VISIBLE_TASKS;
        }
        if folder_count > MAX_VISIBLE_TASKS && start + MAX_VISIBLE_TASKS > folder_count {
            start = folder_count - MAX_VISIBLE_TASKS;
        }
    }

    let horizontal = "â”€".repeat(TABLE_WIDTH);
    println!("\râ•­{}â•®", horizontal);
    table_row(&format!("{TITLE}PASTEL TODO{RESET}"));
    println!("\râ”œ{}â”¤", horizontal);

    table_row(&format!(
        "{ACCENT}Total:{RESET} {:<3}  {ACCENT}Folder:{RESET} {FOLDER_COLOR}{}{RESET} ({})",
        tasks.len(),
        folder,
        folder_count
    ));
    table_row(&format!(
        "{ACCENT}Folder Name:{RESET} {FOLDER_COLOR}{}{RESET}",
        folder
    ));
    println!("\râ”œ{}â”¤", horizontal);

    table_row(" No.  â—‹  Task                                    Date");
    println!("\râ”œ{}â”¤", horizontal);

    let visible_items: Vec<(usize, &Task)> = folder_indices
        .iter()
        .enumerate()
        .skip(start)
        .take(MAX_VISIBLE_TASKS)
        .map(|(order, idx)| (order, &tasks[*idx]))
        .collect();

    for (order, task) in &visible_items {
        let is_selected = selected_idx == Some(*order);
        let pointer = if is_selected {
            format!("{ACCENT}â€º{RESET}")
        } else {
            " ".to_string()
        };
        let status = if task.done {
            format!("{DONE_COLOR}âœ“{RESET}")
        } else {
            format!("{TODO_COLOR}â—‹{RESET}")
        };
        let task_label = truncate(&task.text, TASK_COLUMN_WIDTH);
        let task_colored = if task.done {
            format!("{DONE_COLOR}{}{RESET}", task_label)
        } else {
            format!("{TODO_COLOR}{}{RESET}", task_label)
        };
        let date = format!("{DATE_COLOR}{}{RESET}", task.created_at.format("%d/%m/%y"));
        let row = format!(
            "{pointer} {:>2}.  {status}  {task:<width$} {date}",
            order + 1,
            pointer = pointer,
            status = status,
            task = task_colored,
            width = TASK_COLUMN_WIDTH,
            date = date
        );
        table_row(&row);
    }

    for _ in visible_items.len()..MAX_VISIBLE_TASKS {
        table_row("");
    }

    println!("\râ”œ{}â”¤", horizontal);
    let summary = if folder_count == 0 {
        " Showing 0 tasks in this folder.".to_string()
    } else {
        let start_display = start + 1;
        let end_display = start + visible_items.len();
        format!(
            " Showing {}-{} of {} tasks in this folder.",
            start_display, end_display, folder_count
        )
    };
    table_row(&summary);
    println!("\râ”œ{}â”¤", horizontal);

    match mode {
        Mode::Command => {
            let command_line = format!(" command: {}", truncate(cmd, TABLE_WIDTH - 11));
            table_row(&command_line);
        }
        Mode::Navigate { .. } => {
            table_row(" navigate: â†‘/â†“ move, d marks done, Esc exits");
        }
    }

    let tip_line = format!(
        "{TIP_TEXT}{DIM}{ITALIC}Tip: Shift+D opens navigate; arrows move; d done; Esc exit.{RESET}"
    );
    table_row(&tip_line);

    println!("\râ•°{}â•¯", horizontal);
    let _ = io::stdout().flush();
}

fn truncate(text: &str, len: usize) -> String {
    if text.chars().count() <= len {
        return text.to_string();
    }
    if len <= 3 {
        return ".".repeat(len);
    }

    let mut out = String::new();
    for (i, c) in text.chars().enumerate() {
        if i >= len - 3 {
            out.push_str("...");
            break;
        }
        out.push(c);
    }
    out
}

fn clamp_display(content: &str, width: usize) -> (String, usize) {
    let mut buf = String::with_capacity(content.len());
    let mut visible = 0usize;
    let mut chars = content.chars();
    while let Some(ch) = chars.next() {
        if ch == '\x1b' {
            buf.push(ch);
            while let Some(next) = chars.next() {
                buf.push(next);
                if next == 'm' {
                    break;
                }
            }
            continue;
        }

        if visible >= width {
            continue;
        }

        buf.push(ch);
        visible += 1;
    }
    (buf, visible.min(width))
}

fn table_row(content: &str) {
    let (prepared, visible) = clamp_display(content, TABLE_WIDTH);
    let padding = TABLE_WIDTH.saturating_sub(visible);
    println!("\râ”‚{}{}â”‚", prepared, " ".repeat(padding));
}

fn handle_key(
    key: KeyEvent,
    mode: &mut Mode,
    buffer: &mut String,
    tasks: &mut Vec<Task>,
    folder: &mut String,
) -> bool {
    match mode {
        Mode::Command => handle_command(key, mode, buffer, tasks, folder),
        Mode::Navigate { .. } => {
            handle_navigate(key, mode, tasks, folder);
            false
        }
    }
}

fn handle_command(
    key: KeyEvent,
    mode: &mut Mode,
    buf: &mut String,
    tasks: &mut Vec<Task>,
    folder: &mut String,
) -> bool {
    match key.code {
        KeyCode::Esc => buf.clear(),
        KeyCode::Backspace => {
            buf.pop();
        }
        KeyCode::Char('D') if key.modifiers.contains(KeyModifiers::SHIFT) => {
            if tasks.iter().any(|t| t.folder == *folder) {
                *mode = Mode::Navigate { selected: 0 };
            }
        }
        KeyCode::Char('q') => {
            println!("{ACCENT}See you later!{RESET}");
            println!();
            return true;
        }
        KeyCode::Enter => {
            let cmd = buf.trim().to_lowercase();
            if cmd == "add" {
                if let Some(text) = prompt("New task: ") {
                    tasks.push(Task {
                        text,
                        done: false,
                        folder: folder.clone(),
                        created_at: Local::now(),
                    });
                    save_tasks(tasks).ok();
                }
            } else if cmd == "delete" {
                if let Some(n) = prompt("Delete task #: ") {
                    if let Ok(idx) = n.parse::<usize>() {
                        if idx > 0 {
                            let folder_tasks: Vec<_> = tasks
                                .iter()
                                .enumerate()
                                .filter(|(_, t)| t.folder == *folder)
                                .collect();
                            if let Some((real_idx, _)) = folder_tasks.get(idx - 1) {
                                tasks.remove(*real_idx);
                                save_tasks(tasks).ok();
                            }
                        }
                    }
                }
            } else if cmd == "folder" {
                if let Some(f) = prompt("Switch to folder: ") {
                    *folder = f;
                }
            }
            buf.clear();
        }
        KeyCode::Char(c) => {
            if !key.modifiers.contains(KeyModifiers::CONTROL) {
                buf.push(c);
            }
        }
        _ => {}
    }
    false
}

fn handle_navigate(key: KeyEvent, mode: &mut Mode, tasks: &mut Vec<Task>, folder: &str) {
    let Mode::Navigate { selected } = mode else {
        return;
    };

    let folder_indices: Vec<usize> = tasks
        .iter()
        .enumerate()
        .filter(|(_, t)| t.folder == folder)
        .map(|(idx, _)| idx)
        .collect();

    if folder_indices.is_empty() {
        *mode = Mode::Command;
        return;
    }

    let max_index = folder_indices.len() - 1;
    if *selected > max_index {
        *selected = max_index;
    }

    match key.code {
        KeyCode::Esc => *mode = Mode::Command,
        KeyCode::Up => {
            if *selected > 0 {
                *selected -= 1;
            }
        }
        KeyCode::Down => {
            if *selected < max_index {
                *selected += 1;
            }
        }
        KeyCode::Char('d') => {
            if let Some(&task_idx) = folder_indices.get(*selected) {
                if let Some(task) = tasks.get_mut(task_idx) {
                    task.done = true;
                    save_tasks(tasks).ok();
                }
            }
        }
        _ => {}
    }
}

// ---- File handling ----
fn config_path() -> PathBuf {
    let mut dir = dirs_next::config_dir().unwrap_or_else(|| PathBuf::from("."));
    dir.push("pastel_todo");
    let _ = fs::create_dir_all(&dir);
    dir.push("tasks.tsv");
    dir
}

fn save_tasks(tasks: &[Task]) -> io::Result<()> {
    let mut f = File::create(config_path())?;
    for t in tasks {
        let flag = if t.done { "1" } else { "0" };
        writeln!(
            f,
            "{}\t{}\t{}\t{}",
            flag,
            t.folder,
            t.created_at.to_rfc3339(),
            t.text
        )?;
    }
    Ok(())
}

fn load_tasks() -> Vec<Task> {
    let path = config_path();
    if !path.exists() {
        return Vec::new();
    }
    let file = File::open(path).unwrap();
    let reader = BufReader::new(file);
    reader
        .lines()
        .flatten()
        .filter_map(|l| {
            let p: Vec<&str> = l.splitn(4, '\t').collect();
            if p.len() == 4 {
                let done = p[0] == "1";
                let folder = p[1].to_string();
                let created_at = DateTime::parse_from_rfc3339(p[2])
                    .ok()
                    .map(|d| d.with_timezone(&Local))
                    .unwrap_or_else(Local::now);
                let text = p[3].to_string();
                Some(Task {
                    text,
                    done,
                    folder,
                    created_at,
                })
            } else {
                None
            }
        })
        .collect()
}

fn prompt(msg: &str) -> Option<String> {
    let _ = disable_raw_mode();
    print!("{ACCENT}{msg}{RESET}");
    let _ = io::stdout().flush();
    let mut s = String::new();
    if io::stdin().read_line(&mut s).is_ok() {
        let _ = enable_raw_mode();
        Some(s.trim().to_string())
    } else {
        let _ = enable_raw_mode();
        None
    }
}
